"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.decodeCanisterCallResponse = exports.encodeCanisterCallRequest = exports.encodeEffectivePrincipal = exports.decodeGetStableMemoryResponse = exports.encodeGetStableMemoryRequest = exports.encodeSetStableMemoryRequest = exports.decodeUploadBlobResponse = exports.encodeUploadBlobRequest = exports.decodeAddCyclesResponse = exports.encodeAddCyclesRequest = exports.decodeGetCyclesBalanceResponse = exports.encodeGetCyclesBalanceRequest = exports.decodeGetSubnetIdResponse = exports.encodeGetSubnetIdRequest = exports.encodeSetTimeRequest = exports.decodeGetTimeResponse = exports.decodeSubnetKind = exports.decodeSubnetTopology = exports.decodeInstanceTopology = exports.SubnetType = exports.encodeCreateInstanceRequest = void 0;
const principal_1 = require("@dfinity/principal");
const util_1 = require("./util");
const error_1 = require("./error");
function encodeCreateInstanceRequest(req) {
    const defaultOptions = req ?? { application: 1 };
    const options = {
        nns: defaultOptions.nns ? 'New' : undefined,
        sns: defaultOptions.sns ? 'New' : undefined,
        ii: defaultOptions.ii ? 'New' : undefined,
        fiduciary: defaultOptions.fiduciary ? 'New' : undefined,
        bitcoin: defaultOptions.bitcoin ? 'New' : undefined,
        system: new Array(defaultOptions.system ?? 0).fill('New'),
        application: new Array(defaultOptions.application ?? 1).fill('New'),
    };
    if ((options.nns !== 'New' &&
        options.sns !== 'New' &&
        options.ii !== 'New' &&
        options.fiduciary !== 'New' &&
        options.bitcoin !== 'New' &&
        options.system.length === 0 &&
        options.application.length === 0) ||
        options.system.length < 0 ||
        options.application.length < 0) {
        throw new error_1.TopologyValidationError();
    }
    return options;
}
exports.encodeCreateInstanceRequest = encodeCreateInstanceRequest;
var SubnetType;
(function (SubnetType) {
    SubnetType["Application"] = "Application";
    SubnetType["Bitcoin"] = "Bitcoin";
    SubnetType["Fiduciary"] = "Fiduciary";
    SubnetType["InternetIdentity"] = "II";
    SubnetType["NNS"] = "NNS";
    SubnetType["SNS"] = "SNS";
    SubnetType["System"] = "System";
})(SubnetType || (exports.SubnetType = SubnetType = {}));
function decodeInstanceTopology(encoded) {
    return Object.fromEntries(Object.entries(encoded).map(([subnetId, subnetTopology]) => [
        subnetId,
        decodeSubnetTopology(subnetId, subnetTopology),
    ]));
}
exports.decodeInstanceTopology = decodeInstanceTopology;
function decodeSubnetTopology(subnetId, encoded) {
    return {
        id: principal_1.Principal.fromText(subnetId),
        type: decodeSubnetKind(encoded.subnet_kind),
        size: encoded.size,
        canisterRanges: encoded.canister_ranges.map(range => ({
            start: (0, util_1.base64DecodePrincipal)(range.start.canister_id),
            end: (0, util_1.base64DecodePrincipal)(range.end.canister_id),
        })),
    };
}
exports.decodeSubnetTopology = decodeSubnetTopology;
function decodeSubnetKind(kind) {
    switch (kind) {
        case 'Application':
            return SubnetType.Application;
        case 'Bitcoin':
            return SubnetType.Bitcoin;
        case 'Fiduciary':
            return SubnetType.Fiduciary;
        case 'II':
            return SubnetType.InternetIdentity;
        case 'NNS':
            return SubnetType.NNS;
        case 'SNS':
            return SubnetType.SNS;
        case 'System':
            return SubnetType.System;
        default:
            throw new Error(`Unknown subnet kind: ${kind}`);
    }
}
exports.decodeSubnetKind = decodeSubnetKind;
function decodeGetTimeResponse(res) {
    return {
        millisSinceEpoch: res.nanos_since_epoch / 1_000_000,
    };
}
exports.decodeGetTimeResponse = decodeGetTimeResponse;
function encodeSetTimeRequest(req) {
    return {
        nanos_since_epoch: req.millisSinceEpoch * 1_000_000,
    };
}
exports.encodeSetTimeRequest = encodeSetTimeRequest;
function encodeGetSubnetIdRequest(req) {
    return {
        canister_id: (0, util_1.base64EncodePrincipal)(req.canisterId),
    };
}
exports.encodeGetSubnetIdRequest = encodeGetSubnetIdRequest;
function decodeGetSubnetIdResponse(res) {
    const subnetId = (0, util_1.isNil)(res?.subnet_id)
        ? null
        : (0, util_1.base64DecodePrincipal)(res.subnet_id);
    return { subnetId };
}
exports.decodeGetSubnetIdResponse = decodeGetSubnetIdResponse;
function encodeGetCyclesBalanceRequest(req) {
    return {
        canister_id: (0, util_1.base64EncodePrincipal)(req.canisterId),
    };
}
exports.encodeGetCyclesBalanceRequest = encodeGetCyclesBalanceRequest;
function decodeGetCyclesBalanceResponse(res) {
    return {
        cycles: res.cycles,
    };
}
exports.decodeGetCyclesBalanceResponse = decodeGetCyclesBalanceResponse;
function encodeAddCyclesRequest(req) {
    return {
        canister_id: (0, util_1.base64EncodePrincipal)(req.canisterId),
        amount: req.amount,
    };
}
exports.encodeAddCyclesRequest = encodeAddCyclesRequest;
function decodeAddCyclesResponse(res) {
    return {
        cycles: res.cycles,
    };
}
exports.decodeAddCyclesResponse = decodeAddCyclesResponse;
function encodeUploadBlobRequest(req) {
    return req.blob;
}
exports.encodeUploadBlobRequest = encodeUploadBlobRequest;
function decodeUploadBlobResponse(res) {
    return {
        blobId: new Uint8Array((0, util_1.hexDecode)(res)),
    };
}
exports.decodeUploadBlobResponse = decodeUploadBlobResponse;
function encodeSetStableMemoryRequest(req) {
    return {
        canister_id: (0, util_1.base64EncodePrincipal)(req.canisterId),
        blob_id: (0, util_1.base64Encode)(req.blobId),
    };
}
exports.encodeSetStableMemoryRequest = encodeSetStableMemoryRequest;
function encodeGetStableMemoryRequest(req) {
    return {
        canister_id: (0, util_1.base64EncodePrincipal)(req.canisterId),
    };
}
exports.encodeGetStableMemoryRequest = encodeGetStableMemoryRequest;
function decodeGetStableMemoryResponse(res) {
    return {
        blob: (0, util_1.base64Decode)(res.blob),
    };
}
exports.decodeGetStableMemoryResponse = decodeGetStableMemoryResponse;
function encodeEffectivePrincipal(effectivePrincipal) {
    if ((0, util_1.isNil)(effectivePrincipal)) {
        return 'None';
    }
    if ('subnetId' in effectivePrincipal) {
        return {
            SubnetId: (0, util_1.base64EncodePrincipal)(effectivePrincipal.subnetId),
        };
    }
    else {
        return {
            CanisterId: (0, util_1.base64EncodePrincipal)(effectivePrincipal.canisterId),
        };
    }
}
exports.encodeEffectivePrincipal = encodeEffectivePrincipal;
function encodeCanisterCallRequest(req) {
    return {
        sender: (0, util_1.base64EncodePrincipal)(req.sender),
        canister_id: (0, util_1.base64EncodePrincipal)(req.canisterId),
        method: req.method,
        payload: (0, util_1.base64Encode)(req.payload),
        effective_principal: encodeEffectivePrincipal(req.effectivePrincipal),
    };
}
exports.encodeCanisterCallRequest = encodeCanisterCallRequest;
function decodeCanisterCallResponse(res) {
    if ('Err' in res) {
        throw new Error(res.Err.description);
    }
    if ('message' in res) {
        throw new Error(res.message);
    }
    if ('Reject' in res.Ok) {
        throw new Error(res.Ok.Reject);
    }
    return {
        body: (0, util_1.base64Decode)(res.Ok.Reply),
    };
}
exports.decodeCanisterCallResponse = decodeCanisterCallResponse;
//#endregion CanisterCall
//# sourceMappingURL=pocket-ic-client-types.js.map